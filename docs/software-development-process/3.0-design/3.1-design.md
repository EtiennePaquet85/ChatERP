# 🧠 ChatERP – Conception

---

## 1. 🎯 Objectif du document

Ce document présente la **conception logicielle détaillée** du prototype **ChatERP**, en cohérence avec l’architecture définie. 
Il décrit la structure interne des composants, leurs responsabilités, leurs interactions et la logique de traitement, dans une optique de traçabilité, maintenabilité et conformité aux principes du **SWEBOK v4.0 (2024)**.

---

## 2. 📌 Portée, définitions et références

### 2.1 Portée

Ce document couvre :  

- Les décisions de conception prises pour structurer le prototype ChatERP  
- La vue d’ensemble des modules logiciels et de leurs interactions  
- La décomposition fonctionnelle en composants et modules cohérents  
- Les principes de conception appliqués pour garantir la clarté, la testabilité et la maintenabilité du système

### 2.2 Définitions

| Terme        | Définition                                                                 |
|--------------|----------------------------------------------------------------------------|
| Handler      | Module chargé de la coordination logique et de la validation côté client  |
| Adapter      | Couche d’interface entre deux systèmes, utilisée pour isoler les dépendances externes |
| Router       | Point d’entrée HTTP dans FastAPI, distribuant les requêtes vers les fonctions internes |
| Manager      | Couche intermédiaire encapsulant la logique métier locale dans le module persistance |
| Repository   | Composant dédié à l’accès aux données, généralement associé à une source de persistance |

### 2.3 Références

- Traçabilité [0.2-process-traceability.md]
- Cas d’utilisation [1.3-use-cases.md]  
- Architecture [2.1-architecture.md]
- Guide SWEBOK v4.0 (2024) [IEEE Computer Society]

---

## 3. 🌐 Contexte, objectifs et principes de conception

### 3.1 Contexte

Cette section présente les objectifs et principes de conception appliqués dans le prototype **ChatERP**. Ils s’appuient sur les choix architecturaux définis précédemment et visent à guider la structuration du code, la modularité, la testabilité et la maintenabilité dans la phase de conception détaillée.

### 3.2 Objectifs et principes de conception combinés

| ID         | Objectif / Principe                       | Description combinée                                                                                                    | Alignement |
|------------|-------------------------------------------|-------------------------------------------------------------------------------------------------------------------------|------------|
| DES-OBJ-01 | Modularité / Séparation claire            | Organiser le code en composants ou fichiers correspondant chacun à une seule responsabilité (UI, logique, données)      | ARC-OBJ-01 |
| DES-OBJ-02 | Découplage / Contrats explicites          | Minimiser les dépendances entre modules via des contrats clairs (types, classes, fonctions pures, adaptateurs)          | ARC-OBJ-02 |
| DES-OBJ-03 | Maintenabilité / Isolation fonctionnelle  | Faciliter les modifications et les extensions sans régression par une bonne structuration et documentation              | ARC-OBJ-03 |
| DES-OBJ-04 | Testabilité / Composants testables        | Permettre des tests unitaires simples grâce à des composants autonomes et prévisibles                                   | ARC-OBJ-04 |
| DES-OBJ-05 | Simplicité / Conventions claires          | Réduire la complexité par l’adoption de règles de style simples, explicites et constantes                               | ARC-OBJ-05 |
| DES-OBJ-06 | Interopérabilité / Dépendances maîtrisées | Favoriser l’interconnexion avec d’autres systèmes en limitant les dépendances spécifiques et en utilisant des standards | ARC-OBJ-06 |
| DES-OBJ-07 | Accessibilité  / Structure uniforme       | Faciliter la compréhension du code par l’homogénéité des noms, formats et structures                                    | ARC-OBJ-07 |

---

## 4. 🧱 Vue d’ensemble

ChatERP est constitué de **trois systèmes indépendants** communiquant exclusivement via HTTP, même localement, garantissant un découplage complet.

### 4.1 Structure de l'application

| Système      | Technologies principales                  | Rôle principal                                                                                                          |
|--------------|-------------------------------------------|-------------------------------------------------------------------------------------------------------------------------|
| 🟦 Frontend   | `React (TypeScript)`, React Query, Axios  | Interface utilisateur moderne et typée, gestion locale, appels API fiables vers le Backend.                             |
| 🟩 Backend    | `ASP.NET Core (C#)`, HttpClient, JSON     | Point d’entrée HTTP, centralisation de la logique métier, communication efficace via HttpClient et sérialisation JSON.  |
| 🟨 Database   | `FastAPI (Python)`, SQLite, Pydantic      | API REST CRUD, validation stricte des données, gestion efficace de la persistance.                                      |

### 4.2 Composants principaux

| ID           | Composant       | Système    | Rôle principal                                               | Alignement                                          |
|--------------|-----------------|------------|--------------------------------------------------------------|----------------------------------------------------|
| DES-COMP-01  | Interface       | Frontend   | Présente l’information et capte les interactions utilisateur | ARC-COMP-01, ARC-DEC-01, REQ-F-05                   |
| DES-COMP-02  | Coordination    | Frontend   | Gère les actions utilisateurs et pilote les échanges         | ARC-COMP-01, ARC-DEC-02, REQ-F-05                   |
| DES-COMP-03  | Liaison         | Frontend   | Assure la communication avec les modules distants            | ARC-COMP-01, ARC-DEC-03, REQ-NF-01                  |
| DES-COMP-04  | Entrée          | Backend    | Reçoit les requêtes du client et les distribue               | ARC-COMP-02, ARC-DEC-04, REQ-F-01 à REQ-F-04        |
| DES-COMP-05  | Traitement      | Backend    | Applique la logique métier et organise les opérations        | ARC-COMP-02, ARC-DEC-05, REQ-F-01 à REQ-F-04        |
| DES-COMP-06  | Connexion       | Backend    | Émet des requêtes vers la couche inférieure                  | ARC-COMP-02, ARC-DEC-06, REQ-NF-02                   |
| DES-COMP-07  | Exposition      | Database   | Met à disposition les fonctions de manipulation de données   | ARC-COMP-03, ARC-DEC-07, REQ-NF-03                   |
| DES-COMP-08  | Logique         | Database   | Applique les règles propres à la persistance                 | ARC-COMP-03, ARC-DEC-08, REQ-NF-04                   |
| DES-COMP-09  | Stockage        | Database   | Gère l’accès et la structuration des données persistantes    | ARC-COMP-03, ARC-DEC-09, REQ-NF-05                   |

---

## 5. 🔄 Flux de traitement principal (UC01 – Créer un employé)

Ce flux illustre la collaboration inter-composants à un niveau conceptuel :

1. L’utilisateur soumet un formulaire d’employé depuis l’interface UI.  
2. Le Frontend envoie une requête HTTP vers le Backend.  
3. Le Backend délègue l’opération au cas d’utilisation métier.  
4. Le cas d’utilisation valide les données puis fait un appel HTTP vers le service Database.  
5. La Database persiste les données dans SQLite et renvoie une réponse HTTP confirmée.  
6. La réponse est propagée du Backend vers le Frontend pour mise à jour de l’interface.

Ce flux sera formalisé dans le document de construction avec les détails de mise en œuvre.

---

## 6. ⚙️ Évaluation des solutions organisationnelles

### 6.1 Critères de sélection

| Critère       | Description                                                                                             | Alignement   |
|---------------|---------------------------------------------------------------------------------------------------------|--------------|
| Structuration | Définir une organisation claire des composants logiciels selon leurs responsabilités fonctionnelles     | DES-OBJ-01   |
| Isolation     | Garantir des interactions bien délimitées entre composants par des interfaces explicitement définies    | DES-OBJ-02   |
| Cohésion      | Veiller à ce que chaque composant réalise une tâche précise et limitée pour faciliter les évolutions    | DES-OBJ-03   |
| Fiabilité     | Prendre en compte la testabilité dès la conception pour assurer la qualité et la robustesse du logiciel | DES-OBJ-04   |
| Clarté        | Adopter des choix simples et explicites, évitant les complexités inutiles                               | DES-OBJ-05   |
| Adaptabilité  | Concevoir le système pour qu’il puisse s’intégrer et fonctionner dans divers environnements techniques  | DES-OBJ-06   |
| Lisibilité    | Produire un ensemble clair, bien documenté et compréhensible, conforme aux bonnes pratiques et normes   | DES-OBJ-07   |

### 6.2 Comparaison des solutions

#### 🟦 Organisation Frontend (React + TypeScript)

| Solution | Organisation Frontend (Modules) | Patrons utilisés                     | Structuration | Isolation | Cohésion | Fiabilité | Clarté | Adaptabilité | Lisibilité | Score | Verdict                 |
|----------|---------------------------------|--------------------------------------|---------------|-----------|----------|-----------|--------|--------------|------------|-------|-------------------------|
| A        | components + hooks + services   | Hooks personnalisés, Context API     | ✅            | ✅       | ✅       | ✅        | ⚠️     | ✅          | ✅         | 4.4   | Alternative pertinente  |
| **B**    | components, handlers, adapters  | React Query, Hooks                   | ✅            | ✅       | ✅       | ✅        | ✅     | ✅          | ✅         | 4.7   | ✅ Solution retenue     |
| C        | composants fonctionnels + Redux | Redux, Thunks, Séparation d’état     | ✅            | ✅       | ✅       | ✅        | ⚠️     | ✅          | ✅         | 4.5   | Alternative robuste     |

#### 🟩 Organisation Backend (ASP.NET Core C#)

| Solution | Organisation Backend (Modules)        | Patrons utilisés               | Structuration | Isolation | Cohésion | Fiabilité | Clarté | Adaptabilité | Lisibilité | Score | Verdict                 |
|----------|---------------------------------------|--------------------------------|---------------|-----------|----------|-----------|--------|--------------|------------|-------|-------------------------|
| A        | Controllers, UseCases, Repositories   | Repository + Use Case          | ✅            | ✅       | ✅       | ✅        | ⚠️     | ✅          | ✅         | 4.5   | Alternative solide      |
| **B**    | Controllers, Services, Clients        | Service Layer + Clients HTTP   | ✅            | ✅       | ✅       | ✅        | ✅     | ✅          | ✅         | 4.6   | ✅ Solution retenue     |
| C        | ApiControllers, MediatR, Repositories | CQRS + Mediator Pattern        | ⚠️            | ✅       | ✅       | ✅        | ⚠️     | ✅          | ✅         | 4.3   | Trop complexe           |

#### 🟨 Organisation Database (FastAPI Python)

| Solution | Organisation Database (Modules) | Patrons utilisés                     | Structuration | Isolation | Cohésion | Fiabilité | Clarté | Adaptabilité | Lisibilité | Score | Verdict                  |
|----------|---------------------------------|--------------------------------------|---------------|-----------|----------|-----------|--------|--------------|------------|-------|--------------------------|
| A        | routers, services, repositories | Repository + Service Layer           | ✅            | ✅       | ✅       | ✅        | ⚠️     | ✅          | ✅         | 4.4   | Alternative solide       |
| **B**    | routers, managers, repositories | Clean Architecture + Pydantic Models | ✅            | ✅       | ✅       | ✅        | ✅     | ✅          | ✅         | 4.6   | ✅ Solution retenue      |
| C        | endpoints, crud, schemas        | RESTful API + Pydantic Models        | ✅            | ✅       | ✅       | ✅        | ⚠️     | ✅          | ✅         | 4.5   | Alternative standardisée |

> 📝 **Notation** :
> - ✅ : Répond pleinement au critère  
> - ⚠️ : Répond partiellement ou avec compromis  
> - ❌ : Ne répond pas au critère  
> Le **score final** est une moyenne sur 7 critères.

### 6.3 Solution retenue

🟦 Frontend — B : `components`, `handlers`, `adapters`  
🟩 Backend — B : `Controllers`, `Services`, `Clients`  
🟨 Database — B : `routers`, `managers`, `repositories`  

💡 Cette solution organisationnelle répartit les responsabilités en neuf modules, alignés sur les trois systèmes. Elle garantit une architecture modulaire, claire et évolutive, facilitant le développement progressif et la montée en charge du projet **ChatERP**.

---

## 7. 🔍 Décisions de conception

Les décisions suivantes définissent les modules retenus pour chaque système afin d’assurer leur efficacité, leur cohérence et leur conformité avec les objectifs du projet.

| ID          | Module          | Système   | Décision de conception principale                            | Justification technique                                     | Alignement    |
|-------------|-----------------|-----------|--------------------------------------------------------------|-------------------------------------------------------------|---------------|
| DES-DEC-01  | `components`    | Frontend  | Utiliser des composants fonctionnels pour l’interface UI     | Favorise la réutilisation, la testabilité et la simplicité  | DES-SYS-01    |
| DES-DEC-02  | `handlers`      | Frontend  | Gestion des validations et préparation des données           | Séparation claire des responsabilités, facilite les tests   | DES-SYS-02    |
| DES-DEC-03  | `adapters`      | Frontend  | Isolation des appels HTTP vers le Backend                    | Maintenabilité accrue et meilleure évolutivité              | DES-SYS-03    |
| DES-DEC-04  | `Controllers`   | Backend   | Utilisation du pattern Controller pour gestion des requêtes  | Clarification de la responsabilité et découplage            | DES-SYS-04    |
| DES-DEC-05  | `Services`      | Backend   | Orchestration de la logique métier dans des services dédiés  | Permet une logique métier testable et modulaire             | DES-SYS-05    |
| DES-DEC-06  | `Clients`       | Backend   | Implémentation de clients HTTP typés pour communication API  | Simplifie les appels, facilite le refactoring               | DES-SYS-06    |
| DES-DEC-07  | `routers`       | Database  | Structuration CRUD via routers                               | Architecture modulaire, testable et évolutive               | DES-SYS-07    |
| DES-DEC-08  | `managers`      | Database  | Encapsulation de la logique métier spécifique à la Database  | Séparation claire entre API et accès aux données            | DES-SYS-08    |
| DES-DEC-09  | `repositories`  | Database  | Gestion de la persistance avec Pydantic/SQLModel             | Structure propre, légère et testable sans ORM complexe      | DES-SYS-09    |

---

## 8. 🗂️ Diagrammes de conception

| Diagramme                | Fichier associé                     | Description                            |
|--------------------------|-------------------------------------|----------------------------------------|
| Diagramme de composants  | `component-diagram.puml`            | Vue structurelle des modules           |

📁 Fichiers disponibles dans `docs/software-diagrams/3.0-design/`

---

## 9. 🔚 Conclusion

La conception logicielle présentée répond aux besoins définis dans le document de vision. Elle propose :

- Une modularité claire favorisant la maintenabilité et l’évolution  
- Une organisation centrée sur la testabilité et la flexibilité  
- Un enchaînement structuré pour accompagner les étapes successives du projet  
