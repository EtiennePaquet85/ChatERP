# 🏗️ ChatERP – Architecture

---

## 1. 🎯 Objectif du document

Ce document présente l’architecture logicielle du prototype **ChatERP**. 
Il décrit la structure du système, ses composants, leurs interactions, ainsi que les choix architecturaux visant à satisfaire les exigences fonctionnelles et non fonctionnelles spécifiées dans la vision du système.

---

## 2. 📌 Portée, définitions et références

### 2.1 Portée

Ce document couvre :  

- Les décisions architecturales  
- La vue d’ensemble structurelle  
- La décomposition modulaire  
- Les principes de conception directeurs

### 2.2 Définitions

| Terme     | Définition                                                                 |
|----------|-----------------------------------------------------------------------------|
| Composant | Unité logicielle autonome encapsulant un ensemble cohérent de responsabilités |
| Couplage  | Degré de dépendance entre composants ou modules                           |
| Cohésion  | Degré de spécialisation et d’unicité fonctionnelle d’un composant         |
| MVC       | *Modèle-Vue-Contrôleur* : patron architectural visant à séparer les responsabilités |
| SWEBOK    | *Software Engineering Body of Knowledge* — Référentiel IEEE de pratiques logicielles |

### 2.3 Références

- Traçabilité [0.2-process-traceability.md]
- Vision [1.1-vision.md]  
- Exigences [1.2-requirements.md]  
- Guide SWEBOK v4.0 (2024) [IEEE Computer Society]

---

## 3. 🌐 Contexte, objectifs et principes architecturaux

### 3.1 Contexte

ChatERP est un prototype ERP léger destiné aux PME, avec un accent sur la simplicité, la modularité et la maintenabilité. Il est conçu pour illustrer une démarche rigoureuse conforme au SWEBOK v4.0.

### 3.2 Objectifs et principes architecturaux combinés

| ID         | Objectif / Principe                             | Description combinée                                                                                                       | Alignement                                     |
|------------|-------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------|------------------------------------------------|
| ARC-OBJ-01 | Modularité / Architecture en couches            | Structurer le système en modules séparés (présentation, métier, persistance), avec des composants indépendants             | REQ-NF-02, REQ-CONT-03, REQ-CONT-01            |
| ARC-OBJ-02 | Découplage / Interfaces définies                | Réduire les dépendances entre composants grâce à des interfaces nettes et des adaptateurs entre couches faiblement couplés | REQ-NF-02, REQ-CONT-03                         |
| ARC-OBJ-03 | Maintenabilité / Séparation des responsabilités | Permettre des modifications localisées en assurant que chaque composant a une responsabilité claire et isolée              | REQ-NF-01, REQ-NF-02, REQ-CONT-03, REQ-CONT-02 |
| ARC-OBJ-04 | Testabilité / Architecture testable             | Faciliter la mise en place de tests unitaires et d’intégration grâce à une architecture modulaire et découplée             | REQ-NF-02, REQ-CONT-03                         |
| ARC-OBJ-05 | Simplicité / Optimisation pragmatique           | Favoriser une architecture claire et des solutions simples pour garantir une bonne maintenabilité                          | REQ-F-01, REQ-F-02, REQ-F-03, REQ-NF-04        |
| ARC-OBJ-06 | Interopérabilité / Neutralité technologique     | Assurer la compatibilité multiplateforme et réduire les verrous technologiques                                             | REQ-F-05, REQ-F-06, REQ-NF-05                  |
| ARC-OBJ-07 | Accessibilité  / Standards reconnus             | S’appuyer sur des standards (SWEBOK, bonnes pratiques) pour rendre l’architecture compréhensible et vérifiable             | REQ-NF-01, REQ-NF-03, REQ-CONT-02, REQ-CONT-04 |

---

## 4. 🧱 Vue d’ensemble

### 4.1 Structure de l'application

ChatERP adopte une **architecture en couches**, fondée sur une séparation claire des responsabilités. Chaque couche remplit un rôle fonctionnel bien distinct, permettant une meilleure modularité, testabilité et maintenabilité.

🟦 **Frontend — Interface utilisateur (couche présentation)**  
Responsable de l’interaction avec l’utilisateur final (affichage, navigation, saisie).

🟩 **Backend — Application métier (couche métier)**  
Gère la logique applicative, les règles métier et l’orchestration des cas d’utilisation.

🟨 **Database — Accès aux données (couche données)**  
Assure la persistance, les opérations CRUD et l’intégrité des données.

Les communications entre ces couches sont assurées par des interfaces bien définies, ce qui réduit le couplage et favorise la maintenabilité à long terme.

### 4.2 Composants principaux

| ID           | Composant   | Système    | Rôle principal                                               | Alignement                          |
|--------------|-------------|------------|--------------------------------------------------------------|-------------------------------------|
| ARC-COMP-01  | Affichage   | Frontend   | Présente l’information et recueille les actions de l’usager  | REQ-F-01, REQ-F-02, REQ-NF-02       |
| ARC-COMP-02  | Logique     | Backend    | Exécute les cas d’utilisation et applique les règles métier  | REQ-F-01, REQ-F-03, REQ-NF-02       |
| ARC-COMP-03  | Persistance | Database   | Gère les opérations de lecture et d’écriture sur les données | REQ-F-01, REQ-NF-02, REQ-NF-04      |

---

## 5. 🔒 Communication et sécurité

### 5.1 Communication réseau locale

Les communications entre sous-systèmes sont assurées **exclusivement via des appels HTTP REST**, même en exécution locale.  
Cela permet de garantir un **découplage total** entre les projets et facilite les tests indépendants.

- 🟦 Frontend → 🟩 Backend : `http://localhost:5173/api/`
- 🟩 Backend → 🟨 Database : `http://localhost:8000/api/`

📘 Les appels REST suivent les standards : `GET`, `POST`, `PUT`, `DELETE`, etc.

### 5.2 Exemple de séquence d’appel inter-systèmes

1. Le **Frontend** envoie une requête `POST /api/employees` avec les données d’un nouvel employé.  
2. Le **Backend** valide les données, applique la logique métier, puis appelle la Database.  
3. Le **Backend** envoie une requête `POST /api/employees` à la **Database API** (FastAPI).  
4. Une fois la réponse reçue, le **Backend** la transmet au **Frontend**.

### 5.3 Avantages de la communication HTTP REST

- 🔌 **Interopérabilité** : tout système conforme à HTTP/REST peut interagir avec les services exposés.  
- 🧪 **Testabilité** : chaque composant peut être simulé ou testé indépendamment.  
- 📦 **Modularité** : les composants peuvent être déployés ou mis à jour indépendamment.

### 5.4 Considérations sécurité

- 🔐 **Authentification** des utilisateurs au niveau backend.  
- 🛡️ **Validation stricte** des données côté backend pour prévenir les entrées malveillantes.  
- 🌐 **HTTPS en production** : chiffrement des échanges pour protéger les données en transit.

### 5.5 Gestion des erreurs et tolérance aux pannes

- 📶 Détection explicite des échecs de communication inter-systèmes.  
- 🔁 Stratégies simples de **retry** et gestion des **timeouts**.  
- ⚠️ Affichage clair des erreurs côté utilisateur pour assurer la transparence.

---

## 6. ⚙️ Évaluation des solutions technologiques

### 6.1 Critères de sélection

| Critère       | Description                                                                                       | Alignement |
|---------------|---------------------------------------------------------------------------------------------------|------------|
| Structuration | Le système doit être organisé en modules indépendants (présentation, métier, persistance)         | ARC-OBJ-01 |
| Isolation     | Les échanges entre composants doivent passer par des interfaces clairement définies               | ARC-OBJ-02 |
| Cohésion      | Chaque composant doit avoir une responsabilité précise, facilitant les modifications              | ARC-OBJ-03 |
| Fiabilité     | L’architecture doit permettre la mise en place de tests robustes pour garantir la qualité du code | ARC-OBJ-04 |
| Clarté        | Les choix architecturaux doivent favoriser la simplicité et éviter la complexité inutile          | ARC-OBJ-05 |
| Adaptabilité  | Le système doit fonctionner avec différents environnements et outils sans dépendances fortes      | ARC-OBJ-06 |
| Lisibilité    | L’architecture doit être claire, bien documentée et s’appuyer sur des normes reconnues            | ARC-OBJ-07 |

### 6.2 Comparaison des solutions

| Solution | Frontend     | Backend          | Database                | Structuration | Isolation | Cohésion | Fiabilité | Clarté | Adaptabilité | Lisibilité | Score | Verdict                |
|----------|--------------|------------------|-------------------------|---------------|-----------|----------|-----------|--------|--------------|------------|-------|------------------------|
| A        | Blazor (C#)  | ASP.NET (C#)     | ASP.NET (C#) SQLite     | ❌            | ✅        | ✅      | ⚠️        | ❌     | ✅          | ✅         | 3.5   | Trop homogène          |
| B        | React (TS)   | ASP.NET (C#)     | ASP.NET (C#) SQLite     | ✅            | ✅        | ✅      | ⚠️        | ⚠️     | ✅          | ✅         | 4.2   | Solide, peu diversifié |
| C        | React (TS)   | ASP.NET (C#)     | Flask (Python) SQLite   | ✅            | ✅        | ✅      | ⚠️        | ⚠️     | ✅          | ✅         | 3.8   | Trop bas niveau        |
| **D**    | React (TS)   | ASP.NET (C#)     | FastAPI (Python) SQLite | ✅            | ✅        | ✅      | ✅        | ✅     | ✅          | ✅         | 6.0   | ✅ Solution retenue    |
| E        | React (TS)   | Node.js (TS)     | Express (TS) SQLite     | ✅            | ✅        | ✅      | ✅        | ⚠️     | ✅          | ✅         | 4.0   | Stack JS complet       |
| F        | Angular (TS) | Node.js (TS)     | FastAPI (Python) SQLite | ✅            | ✅        | ✅      | ⚠️        | ⚠️     | ✅          | ✅         | 3.8   | Frontend plus lourd    |
| G        | React (TS)   | FastAPI (Python) | FastAPI (Python) SQLite | ✅            | ✅        | ✅      | ⚠️        | ⚠️     | ✅          | ✅         | 3.7   | Manque de typage fort  |
| H        | React (TS)   | ASP.NET (C#)     | API REST custom SQLite  | ✅            | ✅        | ✅      | ⚠️        | ⚠️     | ✅          | ✅         | 3.9   | Moins standardisé      |

> 📝 **Notation** :
> - ✅ : Répond pleinement au critère  
> - ⚠️ : Répond partiellement ou avec compromis  
> - ❌ : Ne répond pas au critère  
> Le **score final** est une moyenne sur 7 critères.

### 6.3 Solution retenue  

✅ Solution D — React (TypeScript) + ASP.NET Core (C#) + FastAPI (Python)  

💡 Cette solution technologique repose sur trois systèmes indépendants, formant une architecture distribuée claire, maintenable et évolutive. Elle répond pleinement aux critères du projet, en assurant cohérence, séparation des responsabilités et adaptabilité du prototype **ChatERP**.

---

## 7. 🧩 Décisions d’architecture

Les décisions suivantes définissent les technologies principales retenues pour chaque couche du système, avec une justification intégrée, afin d'assurer une architecture cohérente, découplée et conforme aux objectifs de ChatERP.

| ID          | Technologies principales                  | Système   | Justification                                                                                                                                                                                                  | Alignement    |
|-------------|-------------------------------------------|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------|
| ARC-DEC-01  | `React (TypeScript)`, React Query, Axios  | Frontend  | Interface moderne, typée et réactive avec React + TypeScript ; optimisation des performances via cache et gestion des requêtes par React Query ; communication fiable avec Axios.                              | ARC-COMP-01   |
| ARC-DEC-02  | `ASP.NET Core (C#)`, HttpClient, JSON     | Backend   | Centralisation de la logique métier avec ASP.NET Core pour une robustesse et maintenabilité élevées ; communication réseau efficace via HttpClient ; sérialisation performante et typée avec System.Text.Json. | ARC-COMP-02   |
| ARC-DEC-03  | `FastAPI (Python)`, SQLite, Pydantic      | Database  | API REST légère, asynchrone et performante grâce à FastAPI ; validation stricte des données avec Pydantic garantissant intégrité et qualité ; persistance simple et efficace avec SQLite.                      | ARC-COMP-03   |

---

## 8. 🗂️ Diagrammes d’architecture

| Diagramme                | Fichier associé                     | Description                            |
|--------------------------|-------------------------------------|----------------------------------------|
| Diagramme de déploiement | `deployment-diagram.puml`           | Vue des interactions inter-processus   |

📁 Fichiers disponibles dans `docs/software-diagrams/2.0-architecture/`

---

## 9. 🔚 Conclusion

L’architecture proposée respecte fidèlement les exigences du document de vision. Elle offre :

- Une clarté structurelle avec séparation nette des couches  
- Une indépendance technologique favorisant l’illustration d’un ERP moderne distribué  
- Une base robuste pour une mise en œuvre progressive  
