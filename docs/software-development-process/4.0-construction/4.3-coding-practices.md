# 💻 ChatERP — Pratiques de développement

---

## 1. 🎯 Objectif du document

Ce document présente les conventions de codage, les pratiques de développement, et les outils utilisés pour garantir la qualité, la lisibilité et la maintenabilité du code dans le projet **ChatERP**.  
Il s’inscrit dans le chapitre *Software Construction* du SWEBOK V4.0, et complète les éléments de structure décrits dans `4.2-projet-structure.md`.

---

## 2. 🧭 Principes et conventions générales

### Architecture et structure

- Respect strict de la structure modulaire (voir `4.2-projet-structure.md`).  
- Organisation des fichiers selon responsabilités : un fichier = une classe/composant/fonction principale.  
- Nommage idiomatique selon langage : `camelCase.ts`, `PascalCase.cs`, `snake_case.py`.  
- Structure claire par couches (Frontend, Backend, Database).

### Principes fondamentaux

| Principe                         | Description                                                      |
|----------------------------------|------------------------------------------------------------------|
| **Clarté avant tout**            | Code simple à lire, comprendre et modifier.                      |
| **Responsabilités isolées**      | Méthodes/classes courtes dédiées à une responsabilité claire.    |
| **Pas de logique métier en UI**  | Composants UI sans logique métier.                               |
| **Tests en parallèle du code**   | TDD encouragé, tests écrits en même temps que le code.           |
| **Commentaires utiles**          | Expliquer le *pourquoi*, pas le *comment*.                       |
| **Pas de duplication**           | Utilisation de méthodes réutilisables.                           |
| **Architecture propre**          | Séparation claire entre couches métier et infrastructure.        |

### Conventions de nommage

| Élément                   | Convention                         |
|---------------------------|----------------------------------|
| Classes & Interfaces      | `PascalCase`                     |
| Méthodes                  | `PascalCase` avec verbe clair    |
| Variables locales         | `camelCase`                      |
| Constantes                | MAJUSCULES avec underscores      |
| DTOs & Entités            | Noms alignés sur concepts métier |

---

## 3. 🧪 Qualité et gestion des tests

### Contexte et validation

- Développement solo avec support ChatGPT.  
- Suivi Kanban GitHub pour tâches et traçabilité.  
- Revue de code systématique, tests automatisés à chaque commit.  
- Objectif de couverture à 100%, fusion en branche stable seulement après réussite des tests.

### Outils qualité

| Langage    | Linter                     | Formatteur    | Tests                              | Refactorisation             | Vérification types       | Analyse statique |
|------------|----------------------------|---------------|------------------------------------|-----------------------------|--------------------------|------------------|
| TypeScript | eslint + typescript-eslint | prettier      | vitest, msw, Jest Coverage         | TypeScript Language Service | TypeScript natif         | SonarQube        |
| C#         | StyleCop                   | dotnet format | xUnit, Moq, Coverlet               | ReSharper                   | Nullable Reference Types | SonarQube        |
| Python     | flake8                     | black + isort | pytest, unittest.mock, Coverage.py | Rope                        | mypy                     | SonarQube        |

### Tests

- Tests unitaires pour tous services et comportements critiques.  
- Application systématique de la règle AAA (Arrange-Act-Assert).  
- Tests d’intégration pour interactions et bases de données.  
- Utilisation de frameworks adaptés (vitest, xUnit, pytest).

### Indicateurs de qualité

- ✅ **Couverture de tests** : 100% exigée sur services et logique métier.  
- ✅ **Complexité cyclomatique** : seuil maximum de 10 par méthode.  
- ✅ **Duplication de code** : tolérance < 3% (via SonarQube).  
- ✅ **Linting** : zéro avertissement toléré avant merge.  
- ✅ **Temps de test total** : < 30 secondes en local.  
- ✅ **Stabilité des builds CI** : 100% de réussite avant fusion en stable.

---

## 4. 📋 Suivi des tâches et traçabilité opérationnelle

Même en développement solo, un **suivi structuré des tâches** est essentiel pour garantir la rigueur, la priorisation, et la traçabilité des activités de développement.  
Le projet **ChatERP** utilise à cette fin un **Tableau Kanban**, situé dans la section "Projects" du dépôt GitHub principal.

### 📌 Structure du tableau

Le tableau est organisé selon les colonnes standards du flux Kanban :

| Colonne        | Description                                                                 |
|----------------|-----------------------------------------------------------------------------|
| **Backlog**    | Idées, tâches futures ou non planifiées.                                   |
| **Todo**       | Tâches planifiées, prêtes à être commencées.                               |
| **In Progress**| Tâches en cours de développement.                                           |
| **In Review**  | Tâches en cours de relecture, test ou validation.                          |
| **Done**       | Tâches complétées et intégrées au projet.                                  |

Ce système permet de **visualiser l'état d'avancement**, de **prioriser efficacement** les fonctionnalités, et de **documenter les décisions et évolutions** au fil du temps.

### 🔗 Accès

> 🔍 [ChatERP - Tableau Kanban](https://github.com/EtiennePaquet85/ChatERP/projects)

### ✅ Bonnes pratiques adoptées

- Un ticket (ou *item*) est créé pour toute tâche non triviale.  
- Chaque tâche est liée si possible à un commit, une PR ou une exigence fonctionnelle.  
- Le tableau est mis à jour en parallèle du développement, au même titre que les tests et la documentation.  
- Les tâches de refactorisation ou de dette technique sont étiquetées clairement (`#techdebt`).

---

## 5. 🌳 Gestion de versions et collaboration

### Branches Git et commits

| Type          | Préfixe   | Exemple                      |
|---------------|-----------|------------------------------|
| Fonction      | feat/     | feat/create-employee         |
| Correction    | fix/      | fix/validation-error         |
| Refactor      | refactor/ | refactor/employee-service    |
| Documentation | docs/     | docs/construction-principles |

- Syntaxe conventionnelle pour commits (`feat:`, `fix:`, etc.).  
- Exemples : `feat: ajout formulaire`, `fix: correction message erreur`.

### Revue de code

- Relecture systématique avant commit.  
- Checklist courte pour éviter oublis.  
- Usage de ChatGPT pour suggestions et corrections.  
- Workflow Git rigoureux même en solo.

### Traçabilité

- Issues, tickets ou TODO pour besoins et tâches.  
- Lien systématique entre commits et issues.  
- Documentation des évolutions majeures dans le fichier `CHANGELOG.md`.

### Amélioration continue

- Journal de refactorisation tenu dans le `CHANGELOG.md` (section `Refactor`).  
- Dette technique identifiée et taguée en `#techdebt` dans les issues.  
- Revue régulière des modules les plus modifiés pour évaluer leur stabilité.  
- Revue trimestrielle des dépendances et versions utilisées.

---

## 6. ⚠️ Gestion des erreurs et sécurité

### Gestion des erreurs

- Réponses API claires : HTTP 201 confirmation, HTTP 4xx/5xx erreur.  
- Journalisation minimale mais informative.  
- Pas d’exposition des détails internes (stacktrace).  
- Exceptions spécifiques et gestion centralisée des erreurs.  
- Validation systématique dès point d’entrée.  
- Erreurs claires et structurées pour frontend.

### Sécurité

- Ne jamais committer secrets ou identifiants.  
- Validation et filtrage systématique des entrées.  
- Outils d’analyse statique pour vulnérabilités (SonarQube).  
- Principe du moindre privilège.

---

## 7. 📦 Gestion des dépendances et configuration

### Dépendances

- Paquets légers, maintenus, justifiés.  
- Priorité aux solutions éprouvées.  
- Justification obligatoire pour ajout de dépendances.

| Système  | Paquet                                         | Rôle principal                    |
|----------|------------------------------------------------|-----------------------------------|
| Frontend | react-query, axios, zod                        | API, gestion requêtes, validation |
| Backend  | HttpClient, Swashbuckle, FluentValidation      | API, documentation, validation    |
| Database | fastapi, pydantic, sqlite3                     | API Python, schémas, base légère  |

### ⚙️ Configuration

- **Versionnage sémantique (SemVer)** appliqué à tous les sous-systèmes.  
- **Configurations par environnement** via des fichiers `.env` (ex. `.env`, `.env.test`) pour le **Frontend** et la **Database**, et des fichiers `appsettings.{Environment}.json` pour le **Backend**.  
- **Automatisation des tâches répétitives** à l’aide de :  
  - Scripts PowerShell dans des dossiers `scripts/` (ex. `run-all-tests.ps1`, `generate-coverage-report.ps1`),  
  - Fichiers `Makefile` dans la base de données (`systems/database/chaterp-persistence/`),  
  - Outil CLI `.NET` personnalisé (`chaterp-compose/`) pour orchestrer les opérations globales.  
- **Paramètres de configuration locaux** bien délimités dans chaque système :  
  - `appsettings.json` pour le Backend (.NET),  
  - `.env` pour le Frontend (Vite) et la Database (FastAPI),  
  - Fichiers spécifiques à la qualité et au typage (`mypy.ini`, `.flake8`, `tsconfig.json`, etc.).

---

### 📦 Portabilité et packaging

- **Code multiplateforme** : compatible Windows, macOS et Linux.  
- **Reproductibilité des environnements** :  
  - Backend : via fichiers `.csproj` et configuration NuGet,  
  - Frontend : via `package.json` et `tsconfig.json`,  
  - Database : via `requirements.txt` et `pyproject.toml`.  
- **Conteneurisation avec Docker** :  
  - Chaque sous-système possède son propre `Dockerfile`,  
  - Un fichier `docker-compose.yml` global permet l’orchestration centralisée (`docker/`),  
  - Support de déploiement automatisé via `render.yaml`.  
- **Scripts d’initialisation** fournis dans le dossier [`scripts/`](../../scripts/structure/) pour faciliter l’installation du projet et la génération automatique de la structure (`generate-project-structure-files.ps1`, `generate-project-structure-folders.ps1`).

---

## 8. 🚀 Intégration, déploiement et performance

### CI/CD

- Automatisation compilation et tests à chaque commit (ex. GitHub Actions).  
- Déploiement manuel/semi-automatique selon criticité.  
- Blocage des merges en cas d’échec tests.  
- Notifications d’échec activées.

### Performance

- Profilage ponctuel des parties critiques.  
- Tests de charge simples au besoin.  
- Objectif de temps de réponse API : < 300ms pour 95% des requêtes.  
- Scripts de test de charge manuels disponibles (via K6 ou Apache Bench).  
- Optimisations post-analyses des goulots.

---

## 9. 📚 Documentation

- Commentaires expliquant le *pourquoi*, pas le *comment*.  
- Génération automatique de documentation API (Swagger/OpenAPI).  
- Justification claire et détaillée des décisions techniques.

---

## 10. 🔚 Conclusion

Ces pratiques garantissent un développement rigoureux, maintenable et évolutif, malgré un contexte de développement en solo.  
Elles s’appuient sur des standards reconnus, des outils automatisés, et une collaboration active avec ChatGPT pour combler l’absence d’équipe.  
L’adoption des bonnes pratiques de codage favorise la qualité, la pérennité du projet, et la facilité d’évolution sur le long terme.
